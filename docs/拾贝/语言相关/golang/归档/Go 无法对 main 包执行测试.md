# Go 无法对 Main 包执行测试

分析问题之前，我们首先要理清楚 go module, go package, import path 这几个概念。

go package 是 go 的基本编译单元，是 go 从娘胎里就具有的概念。

Go 在 1.11 版本引入了 go module，之后 go module 就代替了 gopath 构建模式成为了 go 的标准构建模式。

go mod 参考手册中关于 go module 的定义是：“一个 module 由一个 module path 来识别，go.mod 文件中声明了 module path 以及关于该 module 的依赖信息，包含 go.mod 文件的目录称为 **module root directory**. main module 是包含调用 go 命令的目录的 module”

	注：本文只讨论 module 构建

go module 的引入是为了解决依赖管理问题。但是 go module 的引入，也对 package 的 import path 的确定与含义产生了些许影响。

GOPATH 构建模式时代，go package 的导入路径（import path）是该 package 所在目录相对于 $GOPATH/src 的路径来确定的。比如你的 package 放在 $GOPATH/src/github.com/usr/repo，那么你的 package 的导入路径就是 import "github.com/user/repo", 这和当时 go get 下载包的路径规则是一致的。

在 GO module 时代，$GOPATH/src 不再被强调，go module 和 $GOPATH/src 没有任何的耦合关系。这时，**go package 的导入路径由 go module path 和 package 在 module 中的相对路径共同确定**。特别注意的是，这里 `import()` 语句仅仅考虑路径（即文件夹名）而对包名没有考虑，但是 go 会将被导入的包的包名默认作为别名，即自动 as <被导入的包名>。

- 如果你的 module path (go.mod 文件中声明) 为 github.com/user/your_module_name, 而你的 package 在 youmodule 根路径下的 foo/bar 目录下，那么你的 package 的导入路径就是 github.com/user/your_module_name/foo/bar。
- 如果采用的 module path 不是上面的 url 的形式，而是类似于 "lemon/lemon_module" 这样的形式，而你的 package 在 lemon_module 路径下的 foo/bar 目录下，那么你的包的导入路径就是 lemon/lemon_module/foo/bar。

	当然，module path 除了作为导入路径的前缀，还可以用来指示 module 存放的版本托管目录的 url 地址。

## Module Root Directory 的包的导入路径是什么

根据上面对 go module 模式下 package 导入路径的定义，go module 根目录下包的导入路径就是 module path。

例如，假设我们有以下的目录结构及内容。

```bash
vscode@VM-8-10-ubuntu:~/desktop/goprogramming/46$ tree .
.
├── go.mod
├── pkg.go
└── pkg_test.go

0 directories, 3 files
vscode@VM-8-10-ubuntu:~/desktop/goprogramming/46$ cat go.mod
module test

go 1.20
vscode@VM-8-10-ubuntu:~/desktop/goprogramming/46$ cat pkg.go
package main

func Add(x, y int) int {
        return x + y
}
vscode@VM-8-10-ubuntu:~/desktop/goprogramming/46$ cat pkg_test.go
package main

import (
        "testing"
)

func TestAdd(t *testing.T) {
        if Add(1, 2) != 3 {
                t.Error("Add(1, 2) != 3")
        }
}
```

那么，这里的 main module 的根路径为 46 目录，该目录下存在了一个包，“46”。那么这个 main 包的导入路径就是 go module 的 module path：“test”。即便你将 pkg.go 中的包名换成别的，那么包的导入路径仍然是 test。

## Go Test 的原理

go test 是 go 内置的测试框架。

在一个包内执行 go test 后，go test 会首先编译目标包 (被测试包)，然后编译测试包，即目录下所有以 \_test.go 为后缀的源文件。go test 会将测试包编译为一个可执行的文件，这个可执行文件的 main 包会依赖并导入测试包，并且会调用测试包中的 TestXxx 导出方法执行测试。

## 最终真相

首先采用 `go test -work` 命令，并查看 go test 执行生成的可执行文件的 main 函数所在的文件夹。

```bash
vscode@VM-8-10-ubuntu:~/desktop/goprogramming/46$ go test -work
WORK=/tmp/go-build294647016
# main.test
/tmp/go-build294647016/b001/_testmain.go:14:8: could not import main (cannot import "main")
FAIL    main [build failed]
```

```bash
vscode@VM-8-10-ubuntu:~/desktop/goprogramming/46$ cat /tmp/go-build294647016/b001/_testmain.go

// Code generated by 'go test'. DO NOT EDIT.

package main

import (
        "os"
        "testing"
        "testing/internal/testdeps"

        _test "main"
)

var tests = []testing.InternalTest{
        {"TestAdd", _test.TestAdd},
}

var benchmarks = []testing.InternalBenchmark{
}

var fuzzTargets = []testing.InternalFuzzTarget{
}

var examples = []testing.InternalExample{
}

func init() {
        testdeps.ImportPath = "main"
}

func main() {
        m := testing.MainStart(testdeps.TestDeps{}, tests, benchmarks, fuzzTargets, examples)
        os.Exit(m.Run())
}
```

我们所看到的这就是我们编译出来的测试可执行文件的 main 包和 main 函数内容，其中最为关键的一行是：

```go
import (
		// ...
        _test "main"
		// ...
)
```

首先我们解释这里为什么是“main”。根据我们之前复习的 go module 下 package 导入路径的定义，这里的 main 其实是测试包的导入路径。同时我们前面说了，这个测试包作为顶层包，其导入路径就是 module-path，而我们这里的 module-path 是 main，因此这里的路径为“main”。

因此问题就来了，这个 \_testmain.go 是 go test 生成的测试可执行程序的 main 包，并且很有可能其导入路径就是 "main"，而现在又多出一个导入路径为 “main” 的，因此会产生循环调用的问题。（自己 import 了自己）

其次，需要说明的是，如果我们的测试包包名为 main（虽然这么命名 test 所在的包的可能是在报复社会），只要导入路径不是单纯的一个 "main"，那么就可以正常运行）即便这个测试包包名同样为 main。

即如果自己本身的导入路径包含在 $\in$ import 包的导入路径，那么肯定 import cycle 了，会报错。如果自己包的包名和被导入包的包名相同，那么无事发生。因此我们可以知道，go test 构建出来的 main 包，其导入路径为 "main"。

因此我们只需要重命名 module path，那么 go test 就可以正常执行了。
