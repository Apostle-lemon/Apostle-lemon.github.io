# [智云课堂] 计算机系统二

## Course Infomation and Policy

课堂上以 linux 操作系统为例，具体实现方式视不同操作系统为准。

### 推荐书籍

- Operating System Concepts - 10th
- Opearating System : Three Easy Pieces

在这两本书之中，老师更推荐第二本书。第一本书会介绍很多以前的计算机操作系统应当如何进行设计的内容。操作系统是与硬件紧密耦合的，但是当时的硬件系统，在今天来看只能得知一个概念，这使得学习非常得肤浅，不能 make your hands dirty（进行实践）。而第二本书，不仅更加前沿，并且更加通俗易懂。

害，这里老师说虽然不推荐第一本书，但还是选择在第一本书上选择题目，因为有些题目题型虽然无聊，但是会在考研题目出现，为了防止我们吃亏，还是在这本书上进行出题。

独立完成并不代表自己闷头做，不和同学交流，不向他人求助。

周老师的这些观点，我是非常认同的，我自己的学习经历得出的是同样的结论。

## Introduction

### Operating System Definition

Kernal 内核，is the program running at all times on the computer。运行在特权态，管理分配硬件资源。`这门课的‘操作系统’是指这个，而不包括 system program` 操作系统存放在 disk 上，运行时被加载到内存当中，由 CPU 进行执行。

### Hardware Components

Direct Memory Access DMA 部件。可以直接控制 memory。DMA 和 CPU 都可以直接访问 memory，这可能会产生数据不一致性。这个数据不一致性可以由硬件协议加以解决。

### Devices

devices controller 设备控制器。每一个设备控制器会存在一个 local buffer。I/O 是发生在 device 和设备控制器的 buffer 之间的。CPU 的数据移动是在 main memory 和设备控制器的 buffer 之间。

CPU 想要控制 devices controller，可以通过两种方式进行操作。第一种是通过特定的 io instruction，这种指令后便会跟 port 的地址。这是一种现代很少见的方式。今天的主流方式是 MMIO，Memory map IO,内存映射型 IO 访问。

### Interrupts and Traps

interrupt vector 中断向量，一个由 service routines 地址组成的表格。dispatch 中断分发。

interrupt handler 会存储被中断时候的状态

trap。类似于 system call，devided-by-zero 都会触发 trap。trap 也可以被理解为 soft-interrupt，即软中断。中断不加前缀词通常指的是硬中断。

操作系统是 interrupt-driven 的。有一种中断为 timer 定时器中断，有了定时器中断才可以有内核代码的执行，进行资源的调度。

### Interrupt Handling

有两种方式可以处理中断。polling 和 vectored interrupt system。

### IO From System Call to Devices, and Back

步骤大致为如下

- program 进行 system call 获得 system resources
- 操作系统发送 io requests
	- io requests 被发送给 device driver，之后会发送给 controller
- OS 可能会让程序等待 block,这种方式叫做同步 IO，也可能直接返回程序，这种方式叫做异步 IO
- IO 结束，IO 控制器 interupt OS
- OS 处理 IO 的结果，之后 wakes up the program，或者向程序发送一个 signal

### DMA Direct Memory Access

DMA 是高速 IO 设备用来传输数据的，可以以一种接近 memory speed 的速度进行 io。device driver 会发送一个 io descriptor 给 controller。这个 io descriptor 内部含有 operation type, memory address 之类的信息。controller 可以通过 DMA，直接在 local buffer 和 main memory 之间进行数据转移，而不需要 CPU intervention。

可能会存在缓存一致性问题。IO MMU input/output memory management unit, 用来表示 physical memory 是暴露给 dma 的。

### NUMA

Non-Uniform memory access system。每一个 cpu 都有自己的 physical memory，但是每个 memory 的地址是同一编址的。

### Operating System Sperations: Multitasking

也被称为 timesharing。就是把 CPU 的运行分为时间片，每个时间片分配给不同的 jobs。

### Dual-mode Operation

dual-mode 就是分为了 user mode 和 kernal mode  
system call 会将 mode 转换为 kernel 状态

risc-v 当中存在三种模式，user 模式。s 模式，这是内核运行的模式。M 模式，这是系统刚起来时运行的固件代码。

### Process Management Activities

进程是处于运行状态的 program。程序 program 为在存储上可执行的一段文件。

![](https://lemonapostlepicgo.oss-cn-hangzhou.aliyuncs.com/img/202211071139652.png)

### Thread

线程。不同进程之间可以通过操作系统提供的进程之间交流的原语，或者共享内存的方式实现数据的共享。但是存在问题：开销过大。

通过 multi-threaded process，使得每个 thread 都具有一个 program counter。每一个线程可以被单独的调度，并且开销资源小。多个线程共享这个进程的数据和代码。

①可被调度的最小基本单元改为了线程。

②进程是资源共享的最小基本单元。

CPU 处于空闲状态时，会运行内核状态中一段特殊的代码。（可以简化理解为 while 1，虽然并不是）

### MMU Memory Management Unit

MMU 可以在虚拟内存和实际内存之间创建一个映射表。

### Resource Management File System

不怎么涉及。

### Resource Management: I/O System Management

分成三个步骤：buffering，caching（将内容从 storage 中读出放入 内存中），spooling(不同外设的输入输出可以相接)。

操作系统会提供设备驱动程序。

手机上，将不同的用户的用户 ID 设置为不一样，再加上设定特定的 access control，可以使得进程之间文件的隔离。

### Separate Policy and Mechanism

Mechanism: how question about a system。如何完成上下文的切换。

Policy: which question。哪个进程应当被切换进来。

### 虚拟化

使得进程认为自己完整拥有硬件资源。

Abstractthe hardware of a single computer (CPU/Memory/IO…) into different environments。

## Os Services & Structures

所谓的 services 就是指操作系统向用户程序提供了什么服务

- User Interface 用户接口，UI
- program execution
- IO operation
- file-system manipulation
- communication
- error detection
- resource allocation
- accounting/logging
- protection and security

### CLI，GUI，Touchscreen Interfaces，Voice Command

命令要么是 built-in 的，要么是其他 program 的名字

fork 会创建子进程，fork 会返回两次

Touchscreen Interfaces 会存在安全隐患 clickjacking 点击劫持，叠加两个用户交互的界面，叠加在上层的界面是恶意软件的，后层是特定按钮。点击后触发的是后层的按钮。

### System Calls

一个 programming 接口，用来 access 操作系统的服务

### Application Programming Interface

API，程序通常不是直接进行系统调用，而是调用 API，可以看做是对系统调用进行了封装

libc 系统库就提供了各种 API。API 隐藏了很多系统调用的细节。

Systemcall 由内核中的异常处理程序进行。不同的系统调用是由系统调用号进行区分的，同样的系统调用在不同的架构下边系统调用号可能是不同的，一个系统号在一个架构下确定了的话，那么基本是不会发生改变的。[系统调用号] 如何传递到内核？这里存在多种方式。①可以通过寄存器进行传递，异常处理程序进行分发的时候则看传进来的参数的值。这是今天比较多的一种实现方式。②机器指令可以带操作数。

系统调用参数的传递可以通过 ① register。缺点是寄存器的个数和大小都是固定的。② block 传递一连块内存，内存的地址通过寄存器传递 ③ stack。扯开：push 和 pop 指令是伪指令，编译器会替换为真正的机器指令。今天的 cpu 内部还真他妈有硬件栈，hardware stack，只不过其是透明的，会自动保存一份关键值到硬件栈中，如返回地址一类。return 指令时硬件层面会比较影子栈中的返回地址和当前返回是否一致。

### Types of System Calls

- process control 操作系统内核在被引导完后，会主动创建出一个进程号为 1 的进程。会存在一个进程树。`kill -9 pid`，终止进程。load execute，加载新的。
- file managment
- information maintenance。getpid 所需要的具体花费很小，很大的开销放在了上下文的切换，因此经常用 getpid 来测试上下文切换的系统开销。
- communications。进程和进程之间共享 memory。默认时，进程和进程之间的内存空间是相互隔离的，由于操作系统做了内存虚拟化。
- protection

### C 语言中的 Fork

构造一个子进程，子进程是父进程的精确拷贝，但是 pid = fork () 这里的 pid 并不会被拷贝，因此可以通过判断 pid 来判断当前处于父进程还是子进程。

lic.so 是加载的动态库，动态链接时并不在对应的可执行文件之中。

### Case Study Ioctl

ioctl 可以看作是一个通用的接口。

### Linkers & Loaders

loader 是加载器，是 from program to process

在运行时会有动态链接过程。

通过静态链接方式，则代码都会被嵌入到最终的可执行文件内部。好处时自包含，不依赖于系统库代码。缺点是可执行文件大小非常大，加载的时候会比较慢。静态链接在不同的进程之间很难共享系统代码。即内存中可能会存在 printf（）的完整实现的多份拷贝。

#### 动态链接

![](https://lemonapostlepicgo.oss-cn-hangzhou.aliyuncs.com/img/202211201518961.png)  

可以看到调用 printf 的时候会跳转到 488 处。做了两次 add 的操作，第一次 add 是将当前寄存器的值放到 ip 寄存器内部。第二次 add 是将 ip 加上了一个常数。第三次操作则是做了一次间接跳转，将 ip 加上 2904 处的值，放置到 pc 之中。这么说来在 0x2fe8 之中，就应该是 printf 函数在运行时在内存中的值。

将 printf 函数的地址，填到 0x2fe8 这件事，一种做法是是由加载器加载可执行文件时即完成，ELF 文件会表明自己依赖于哪些系统库。加载器会根据库文件所在的路径，将 libc 加载到内存之中。还需要将 libc 中 printf 的地址放到 0x2fe8 之中。这里可以作证链接时候的行为会改变加载时候的行为。

当然还有一种 延迟绑定 lazy binding 的方法，将更改 0x2fe8 处的值这件事放到真正调用 printf 时再去执行。这样可以在分支情况下合理的进行。

动态链接使得①可执行文件的大小大量地减少了。②并且能够比较好的在不同的进程之间共享系统库。我们可以知道虚拟内存存在映射，因此只需要调整映射关系即可，可以在实际内存中只保留一份 libc。

可以通过函数运行时等方式掩盖程序对 OS 的依赖。所谓的运行时，就是指一种虚拟机，最终是由 虚拟机 来执行的。虚拟机会判断环境，实现自己的实现。

### Operating System Structure

新设计操作系统内核，如何组织会更加合理。

机制 mechanism：如何保存上下文进行切换  
策略 policy：下一个要被调度的进程是什么
