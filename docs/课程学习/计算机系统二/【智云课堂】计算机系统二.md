# [智云课堂] 计算机系统二

## Course Infomation and Policy

课堂上以 linux 操作系统为例，具体实现方式视不同操作系统为准。

### 推荐书籍

- Operating System Concepts - 10th
- Opearating System : Three Easy Pieces

在这两本书之中，老师更推荐第二本书。第一本书会介绍很多以前的计算机操作系统应当如何进行设计的内容。操作系统是与硬件紧密耦合的，但是当时的硬件系统，在今天来看只能得知一个概念，这使得学习非常得肤浅，不能 make your hands dirty（进行实践）。而第二本书，不仅更加前沿，并且更加通俗易懂。

害，这里老师说虽然不推荐第一本书，但还是选择在第一本书上选择题目，因为有些题目题型虽然无聊，但是会在考研题目出现，为了防止我们吃亏，还是在这本书上进行出题。

独立完成并不代表自己闷头做，不和同学交流，不向他人求助。

周老师的这些观点，我是非常认同的，我自己的学习经历得出的是同样的结论。

## Introduction

### Operating System Definition

Kernal 内核，is the program running at all times on the computer。运行在特权态，管理分配硬件资源。`这门课的‘操作系统’是指这个，而不包括 system program` 操作系统存放在 disk 上，运行时被加载到内存当中，由 CPU 进行执行。

### Hardware Components

Direct Memory Access DMA 部件。可以直接控制 memory。DMA 和 CPU 都可以直接访问 memory，这可能会产生数据不一致性。这个数据不一致性可以由硬件协议加以解决。

### Devices

devices controller 设备控制器。每一个设备控制器会存在一个 local buffer。I/O 是发生在 device 和设备控制器的 buffer 之间的。CPU 的数据移动是在 main memory 和设备控制器的 buffer 之间。

CPU 想要控制 devices controller，可以通过两种方式进行操作。第一种是通过特定的 io instruction，这种指令后便会跟 port 的地址。这是一种现代很少见的方式。今天的主流方式是 MMIO，Memory map IO,内存映射型 IO 访问。

### Interrupts and Traps

interrupt vector 中断向量，一个由 service routines 地址组成的表格。dispatch 中断分发。

interrupt handler 会存储被中断时候的状态

trap。类似于 system call，devided-by-zero 都会触发 trap。trap 也可以被理解为 soft-interrupt，即软中断。中断不加前缀词通常指的是硬中断。

操作系统是 interrupt-driven 的。有一种中断为 timer 定时器中断，有了定时器中断才可以有内核代码的执行，进行资源的调度。

### Interrupt Handling

有两种方式可以处理中断。polling 和 vectored interrupt system。

### IO From System Call to Devices, and Back

步骤大致为如下

- program 进行 system call 获得 system resources
- 操作系统发送 io requests
	- io requests 被发送给 device driver，之后会发送给 controller
- OS 可能会让程序等待 block,这种方式叫做同步 IO，也可能直接返回程序，这种方式叫做异步 IO
- IO 结束，IO 控制器 interupt OS
- OS 处理 IO 的结果，之后 wakes up the program，或者向程序发送一个 signal

### DMA Direct Memory Access

DMA 是高速 IO 设备用来传输数据的，可以以一种接近 memory speed 的速度进行 io。device driver 会发送一个 io descriptor 给 controller。这个 io descriptor 内部含有 operation type, memory address 之类的信息。controller 可以通过 DMA，直接在 local buffer 和 main memory 之间进行数据转移，而不需要 CPU intervention。

可能会存在缓存一致性问题。IO MMU input/output memory management unit, 用来表示 physical memory 是暴露给 dma 的。

### NUMA

Non-Uniform memory access system。每一个 cpu 都有自己的 physical memory，但是每个 memory 的地址是同一编址的。

### Operating System Sperations: Multitasking

也被称为 timesharing。就是把 CPU 的运行分为时间片，每个时间片分配给不同的 jobs。

### Dual-mode Operation

dual-mode 就是分为了 user mode 和 kernal mode  
system call 会将 mode 转换为 kernel 状态

risc-v 当中存在三种模式，user 模式。s 模式，这是内核运行的模式。M 模式，这是系统刚起来时运行的固件代码。

### Process Management Activities

进程是处于运行状态的 program。程序 program 为在存储上可执行的一段文件。

![](https://lemonapostlepicgo.oss-cn-hangzhou.aliyuncs.com/img/202211071139652.png)

### Thread

线程。不同进程之间可以通过操作系统提供的进程之间交流的原语，或者共享内存的方式实现数据的共享。但是存在问题：开销过大。

通过 multi-threaded process，使得每个 thread 都具有一个 program counter。每一个线程可以被单独的调度，并且开销资源小。多个线程共享这个进程的数据和代码。

①可被调度的最小基本单元改为了线程。

②进程是资源共享的最小基本单元。

CPU 处于空闲状态时，会运行内核状态中一段特殊的代码。（可以简化理解为 while 1，虽然并不是）

### MMU Memory Management Unit

MMU 可以在虚拟内存和实际内存之间创建一个映射表。

### Resource Management File System

不怎么涉及。

### Resource Management: I/O System Management

分成三个步骤：buffering，caching（将内容从 storage 中读出放入 内存中），spooling(不同外设的输入输出可以相接)。

操作系统会提供设备驱动程序。

手机上，将不同的用户的用户 ID 设置为不一样，再加上设定特定的 access control，可以使得进程之间文件的隔离。

### Separate Policy and Mechanism

Mechanism: how question about a system。如何完成上下文的切换。

Policy: which question。哪个进程应当被切换进来。

### 虚拟化

使得进程认为自己完整拥有硬件资源。

Abstractthe hardware of a single computer (CPU/Memory/IO…) into different environments。

## Os Services & Structures

所谓的 services 就是指操作系统向用户程序提供了什么服务

- User Interface 用户接口，UI
- program execution 
- IO operation
- file-system manipulation
- communication
- error detection
- resource allocation
- accounting/logging
- protection and security

### CLI，GUI，Touchscreen Interfaces，Voice Command

命令要么是 built-in 的，要么是其他 program 的名字

fork 会创建子进程，fork 会返回两次

Touchscreen Interfaces 会存在安全隐患 clickjacking 点击劫持，叠加两个用户交互的界面，叠加在上层的界面是恶意软件的，后层是特定按钮。点击后触发的是后层的按钮。

### System Calls

一个 programming 接口，用来 access 操作系统的服务

### Application Programming Interface

API，程序通常不是直接进行系统调用，而是调用 API，可以看做是对系统调用进行了封装

libc 系统库就提供了各种 API。API 隐藏了很多系统调用的细节。

Systemcall 由内核中的异常处理程序进行。不同的系统调用是由系统调用号进行区分的。[系统调用号]如何传递到内核？这里存在多种方式。①可以通过寄存器进行传递，异常处理程序进行分发的时候则看传进来的参数的值。这是今天比较多的一种实现方式。②机器指令可以带操作数。

系统调用参数的传递可以通过 ① register。缺点是寄存器的个数和大小都是固定的。② block 传递一连块内存，内存的地址通过寄存器传递 ③ stack。扯开：push 和 pop 指令是伪指令，编译器会替换为真正的机器指令。
