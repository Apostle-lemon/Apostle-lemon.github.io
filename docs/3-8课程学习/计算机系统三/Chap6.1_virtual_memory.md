# Chap6.1_Virtual_Memory

主要讲的是 demand of paging

	在 memory 相关概念中，TLB 指代什么

当程序访问虚拟内存时，CPU 将虚拟地址转换为物理地址。这个转换过程通常需要查询页表，以确定虚拟页对应的物理页框。为了提高性能，TLB 存储了最近使用过的一些虚拟页表项，避免了每次都要查询主存的开销。TLB 通过缓存这些页表项，可以加速地址转换的速度。

当程序使用一个虚拟地址时，CPU 首先检查 TLB 中是否存在该地址的对应项。如果存在，CPU 直接从 TLB 中获取物理地址，加快地址转换的速度。如果 TLB 中没有对应项，CPU 将访问主存来获取缺失的页表项，并将其加载到 TLB 中，以备将来的访问使用。

	我不明白“Consider ability to execute partially-loaded program”，请你为我解释

通常情况下，计算机执行程序时需要将整个程序加载到内存中，然后逐行或逐条指令地执行。但是，有些情况下程序可能非常大，超过了系统的物理内存容量。在这种情况下，传统的做法是无法执行这样的大型程序的。

然而，如果计算机系统具备部分加载程序的能力，它可以先加载部分程序代码和数据到内存中，然后开始执行已加载的部分。随后，系统可以根据需要逐步加载程序的其他部分。这样，程序就不再受到物理内存限制，可以被拆分成多个部分进行加载和执行。

	我不明白 Pages can be shared during fork(), speeding process creation: COW，请你为我解释

在fork()函数中，页面可以进行共享，从而加快进程的创建速度。这是通过写时复制（Copy-On-Write，COW）机制实现的。

当一个进程调用fork()函数创建一个新的子进程时，通常情况下，操作系统会复制父进程的整个地址空间给子进程。这包括代码、数据、堆、栈等。但是，为了提高效率，实际上操作系统并不立即复制所有的页面，而是使用COW机制。

COW机制的核心思想是，父进程和子进程最初共享相同的物理内存页面。也就是说，父进程和子进程指向相同的物理页面。只有当其中一个进程试图修改这个页面时，操作系统才会复制该页面，使得父进程和子进程拥有各自的副本。

这样，通过共享页面和延迟复制的方式，fork()函数在创建子进程时可以更快地完成，因为它避免了复制整个地址空间的开销。而且，在父进程和子进程之间只有在需要修改的页面上才会发生复制，这使得内存使用效率更高。

## EAT

Page fault rate: 0 ≤p≤ 1  

- if p = 0 no page faults  
- if p = 1, every reference is a fault

Effective Access Time (EAT):  

- (1 – p) x memory access+ p x (page fault overhead + swap page out + swap page in + instruction restart overhead)

## COW

	我不明白 vfork could be fragile, it is invented when COW has not been implemented 请您为我阐释

在计算机系统中，vfork是一种创建子进程的系统调用，它与传统的fork系统调用类似，但有一些差异。vfork的设计初衷是为了在创建子进程时避免复制父进程的地址空间，以节省时间和内存开销。

然而，在写时复制机制实现之前，vfork的实现方式比较简单粗暴，可能会导致一些问题。在vfork中，子进程与父进程共享相同的地址空间。这意味着在子进程执行期间，如果对地址空间进行了修改，可能会对父进程产生意外的影响。

在写时复制机制实现后，当父进程或子进程试图修改共享页面时，才会进行页面复制，从而避免了父子进程之间的不稳定性和冲突。写时复制机制确保了父进程和子进程可以并发执行，而不会相互干扰。

## Page Replacement

	need to reduce overhead and avoid thrashing 这里的 thrashing 是什么意思

"需要减少开销并避免抖动"，这里的 "抖动"（thrashing）指的是一种在内存管理中的现象。

抖动发生在系统中当有过多的页面频繁被置换（换入和换出）时。这种情况下，系统花费了大量的时间和资源在页面的换入和换出操作上，而不是真正执行有用的工作。抖动通常发生在系统内存不足的情况下，导致系统频繁地进行页面置换，而这种过度的页面置换反过来又导致了更多的页面置换，从而陷入了一个无限循环的状态。

当抖动发生时，系统性能显著下降。由于频繁的页面置换操作，导致大量的磁盘I/O和页面错误，从而增加了系统的延迟和开销。此外，抖动还会导致CPU利用率下降，因为大量的时间花费在页面置换而不是实际的计算任务上。

	我不明白 Belady’s Anomaly，请你为我阐释

Belady's Anomaly（贝拉第现象）是指在页面置换算法中的一种现象，即增加物理页面数量时，有时会导致缺页次数增加的情况。

通常情况下，增加物理页面的数量可以降低缺页次数，因为更多的页面可以容纳更多的活跃页面，减少了页面置换的频率。然而，贝拉第现象表明，有时增加物理页面的数量反而会导致缺页次数增加。

	我不明白 When page replacement called for, use the clock scheme but use the four classes replace page in lowest non-empty class，请您为我阐释

当需要进行页面替换时，使用时钟算法（clock scheme），但选择四个类别中最低非空类别来替换页面。

在内存管理中，当物理内存不足时，需要选择一些页面进行替换，以便为新的页面提供空间。时钟算法是一种常见的页面置换算法之一，用于选择要替换的页面。

时钟算法基于一个循环链表，每个页面都有一个标志位（通常是"访问位"或"修改位"）。当需要进行页面替换时，算法从当前指针所指向的页面开始遍历链表。如果页面的标志位为0（即未被访问或修改），则选择该页面进行替换。如果标志位为1，则将其设置为0，并继续遍历链表直到找到一个标志位为0的页面。

然而，在提到 "四个类别" 时，表示时钟算法的改进或变体。具体来说，物理内存中的页面可以被分为四个不同的类别（例如：Class 0、Class 1、Class 2、Class 3），每个类别包含一组页面。

当需要进行页面替换时，时钟算法将选择最低非空的类别中的页面进行替换。这意味着算法首先检查 Class 0，如果该类别中没有非空页面，则检查 Class 1，然后是 Class 2，最后是 Class 3。从这四个类别中选择最低非空类别的目的是尽可能减少对活跃页面的替换，以提高系统性能和效率。

	我不明白 Might need to search circular queue several times，请您为我阐释

在内存管理中，时钟算法（clock algorithm）通常使用循环队列来组织和管理页面。循环队列是一个环形的数据结构，用于存储页面的信息。

当需要进行页面替换时，时钟算法从当前指针所指向的页面开始遍历循环队列，以找到一个适合替换的页面。然而，有时需要进行多次搜索才能找到合适的页面。

这是因为循环队列的指针可能需要多次循环遍历整个队列，才能找到一个合适的页面。在每次遍历过程中，算法检查页面的标志位（通常是访问位或修改位），以确定页面是否适合替换。

当需要多次搜索循环队列时，意味着当前指针在第一次遍历时可能没有找到一个合适的页面，因此需要进行额外的遍历来寻找合适的替换页面。

这种情况可能发生在队列中的所有页面都被访问或修改过，或者需要等待某些页面的标志位转为0，才能找到适合替换的页面。

因此，在时钟算法中，有时可能需要多次搜索循环队列，以找到一个合适的页面进行替换。这样的搜索过程可以确保选择最适合替换的页面，以优化内存管理和页面置换的效果。

	LFU replaces page with the smallest counter，这里的 LFU 是什么的缩写

"LFU" 是 "Least Frequently Used" 的缩写，中文意为 "最不经常使用"。注重的是频次的概念。

	并没有搞懂 Keep some as free frame buffer pool

	Major and minor page faults 这一节是什么意思

	看一看最后的内容，不想看PPT了
