# 编译原理 Chap6 活动记录

活动记录，就是栈帧。

## 高阶函数

嵌套函数：内层函数和外层函数。

将嵌套函数与作为返回值返回的函数两种情况组合出现时，将导致函数内的局部变量需要的生命期超过函数本身的生命期。

Tiger 允许函数嵌套，但不允许将函数作为返回值，因此可以用栈来保存局部变量。

如果一种语言，同时允许函数嵌套和将函数作为返回值，那么这个函数被称为高阶函数 higher-order function。这些语言不能用栈来保存所有的局部变量。

## 栈帧

栈中用来存放一个函数的局部变量、参数、返回地址和其他临时变量的这片区域称为该函数的活动记录或栈帧。

栈在存储器中总是从高地址开始并向低地址方向增长。

	 技术上，这些传入的参数是前一个栈帧的一部分，但是他们位于相对帧指针的位移是已知的单元中

在函数调用过程中，每个函数的执行都有一个对应的活动记录（栈帧）。当一个函数调用另一个函数时，前一个函数的活动记录成为后一个函数的"前一个栈帧"。这个描述指的是传入的参数（即前一个函数传递给后一个函数的值）在技术上是前一个栈帧的一部分。

"位于相对帧指针的位移是已知的单元"的意思是，传入的参数相对于当前函数的栈帧，可以通过已知的位移来访问。栈帧中通常包含一个指针，称为帧指针（Frame Pointer），它指向当前栈帧的起始位置。通过使用已知的位移（即相对于帧指针的偏移量），可以准确定位传入参数在栈帧中的位置。

换句话说，当一个函数被调用时，它的参数被传递给它的活动记录，这些参数存储在前一个函数的栈帧中。通过使用帧指针和已知的位移，可以在当前函数的栈帧中访问这些传入的参数。这样，后一个函数就可以使用前一个函数传递的值来执行相应的操作。

### 帧指针

栈帧的大小要到编译处理相当晚的时候才能知道，即要到给临时变量分配的空间大小和用于保护寄存器的空间大小都已确定时。

因此，即便栈帧的大小可以是常数，仍然需要帧指针。

	形式参数，局部变量，临时变量分别是什么意思

形式参数（Formal Parameters）是在函数或方法定义中声明的变量。它们用于接收函数调用时传递的实际参数（实参）的值。形式参数在函数内部被当作局部变量使用，用于在函数执行过程中进行计算和操作。

局部变量（Local Variables）是在函数、方法或代码块内部声明的变量。它们的作用域仅限于声明它们的函数、方法或代码块内部。局部变量在其所属的作用域中被分配和使用，当函数或方法执行完毕或代码块结束时，局部变量的生命周期也结束，它们的值将不再可访问。

临时变量（Temporary Variables）是在计算过程中使用的临时存储空间。它们用于临时保存计算结果、中间值或其他临时数据。临时变量的作用域通常是局部的，仅在其所在的代码段内有效，并且它们的值往往在计算结束后被丢弃或重用。

### 寄存器

根据保存和恢复寄存器的责任归属，可以分为 caller-save 和 callee-save 两种模式。

### 栈帧中的变量

如果一个参数是传地址实参，或者它被选取了地址，或者内层的嵌套函数对其进行了访问，我们则称该变量是逃逸的

	我在看一本书，书中这样阐释“如果一个参数是传地址实参，或者它被选取了地址，或者内层的嵌套函数对其进行了访问，我们则称该变量是逃逸的”，我并不理解什么是传地址实参，请你为我阐释

传地址实参是指在函数调用时，将变量的地址作为参数传递给函数。具体而言，当我们在调用函数时，将某个变量作为参数传递给函数，并且在函数内部对该参数进行操作时，实际上是对该变量在内存中的地址进行操作，而不是对变量本身进行操作。这样的参数传递方式被称为传地址实参。

传地址实参的好处是可以直接在函数内部修改传递的变量的值，而不仅仅是修改其副本。这对于需要在函数内部改变变量值并且保持改变后的值在函数外部可见的情况非常有用。通过传递地址实参，函数可以直接访问和修改原始变量，而不需要创建额外的副本。

### 静态链

在允许声明嵌套函数的语言中，内层函数可以使用外层函数声明的变量，这种语言特征称为块结构 block structure。

每当一个函数被调用时，都将传递给他一个指针，该指针指向程序正文中直接包含 f 的函数的活动记录。即传递了帧指针。

注意“静态”概念，所谓的静态就是指程序源代码所表明的包含关系。

## Tiger 编译器的栈帧

### 栈帧描述的表示

tiger 中，F_frame 是一个包含以下信息的数据结构

- 所有形式参数的位置
- 实现“视角位移”需要的指令
- 迄今为止已分配的栈帧大小
- 该函数开始点的机器代码标号

### 局部变量

在 tiger 中，采用 F_allocaLocal(f,bool) 就可以在函数 f 中分配变量所需的空间。参数值 bool 代表了该变量是否是逃逸的。如果是逃逸的，那么返回的就是 Inframe，否则返回的可能是 InReg()。

### 计算逃逸变量

非逃逸的局部变量可以分配到寄存器中，而逃逸的局部变量必须分配在栈帧中。

FindEscape 函数可以找出逃逸变量。FindEscape 函数必须在语义分析之前。

### 临时变量和标号

术语 临时变量 表示暂时保存在寄存器中的值，并且用术语 标号 表示其精准地址还需要确定的某种机器语言的位置。